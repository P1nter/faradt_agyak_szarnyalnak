import java.util.ArrayList;
import java.util.List;
import java.util.Observer;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Manages the overall game state, including Tektons, players, and turn progression.
 * <p>
 * The {@code Game} class is responsible for initializing and controlling the flow
 * of the game. It maintains collections of {@code Tekton} objects (representing
 * locations or areas in the game world) and {@code Player} objects. It also handles
 * the active player, turn transitions, and game updates. The class includes
 * functionality for splitting Tektons, adding and removing players and Tektons,
 * determining the winner, and updating game elements each turn.
 * </p>
 *
 * @since 1.0
 */
public class  Game {
    private List<Tekton> tektons;
    private List<Player> players;

    private Player activePlayer;

    /**
     * Constructs a new {@code Game} instance.
     * <p>
     * Initializes the lists for Tektons and players. The game map is not loaded
     * or generated by default in this constructor. Players need to be added
     * explicitly.
     * </p>
     */
    public Game() {
        tektons = new ArrayList<>();
        players = new ArrayList<>();
    }
    public Game(List<Tekton> tektons, List<Player> players){
        this.tektons = tektons;
        this.players = players;
    }

    public void setTektons(List<Tekton> tektons){
        this.tektons = tektons;
    }
    public void setPlayers(List<Player> players){
        this.players = players;
    }

    /**
     * Splits a given {@code Tekton} into two separate Tektons.
     * <p>
     * This method takes a {@code Tekton} as input and divides its adjacent
     * Tektons and inhabiting insects roughly in half, creating a new {@code Tekton}
     * with one half while the original retains the other. The mushroom associated
     * with the original Tekton has its body removed, and a new mushroom is created
     * for the newly formed Tekton. Any yarn connections involving the original
     * Tekton are updated to reflect the split. The new {@code Tekton} is then
     * added to the game's collection of Tektons.
     * </p>
     *
     * @param tekton The {@code Tekton} to be split. This Tekton will be modified
     * as part of the splitting process.
     */
    public void split(Tekton tekton){
        //split the tekton into two tektons
        int half = tekton.getAdjacentTektons().size()/2;
        List<Tekton> newadjacentTektons = new ArrayList<>();
        for(int i = 0; i < half; i++){
            newadjacentTektons.add(tekton.getAdjacentTektons().get(i));
            for(Tekton tekton1 : tekton.getAdjacentTektons()){
                tekton1.getAdjacentTektons().remove(tekton);
            }
            tekton.getAdjacentTektons().remove(i);

        }

        Tekton newTekton = new DefaultTekton(newadjacentTektons);
        int halfInsects = tekton.getInsects().size()/2;
        for(int i = 0; i < halfInsects; i++){
            tekton.getInsects().get(i).setTekton(newTekton);
            tekton.getInsects().remove(i);
            newTekton.addNewInsect(tekton.getInsects().get(i));
        }
        tekton.getMushroom().removeMushroomBody();
        //delete all yarn from tekton
        for(MushroomYarn mushroomYarn : tekton.getMushroom().getMushroomYarns()){
            mushroomYarn.getTektons()[0].getMushroom().getMushroomYarns().remove(mushroomYarn);
            mushroomYarn.getTektons()[1].getMushroom().getMushroomYarns().remove(mushroomYarn);
        }
        //newadjacentTektons.add(tekton);
        tekton.addAdjacentTekton(newTekton);
        Mushroom newMushroom = new Mushroom();
        newTekton.setMushroom(newMushroom);

        //add the new tekton to the game
        tektons.add(newTekton);

    }

    /**
     * Adds a new player to the game.
     *
     * @param player The {@code Player} object to be added to the game's list of players.
     */
    public void addPlayer(Player player){
        players.add(player);
    }

    /**
     * Adds a new Tekton to the game.
     *
     * @param tekton The {@code Tekton} object to be added to the game's collection of Tektons.
     */
    public void addTekton(Tekton tekton) {
        tektons.add(tekton);
    }

    /**
     * Removes a Tekton from the game.
     *
     * @param tekton The {@code Tekton} object to be removed from the game's collection of Tektons.
     */
    public void removeTekton(Tekton tekton) {
        tektons.remove(tekton);
    }

    /**
     * Removes a player from the game.
     *
     * @param player The {@code Player} object to be removed from the game's list of players.
     */
    public void removePlayer(Player player){
        players.remove(player);
    }


    public void list() {
        for (Tekton tekton : tektons) {
            // Cache tekton ID to avoid any unexpected changes
            final int tektonId = tekton.getIDNoPrint();
            System.out.println();
            System.out.println("ID: " + tektonId);

            // Adjacent Tektons
            List<Tekton> adjacent = tekton.getAdjacentTektonsNoPrint();
            System.out.println("Adjacent Tektons: " +
                    (adjacent == null || adjacent.isEmpty()
                            ? "None"
                            : adjacent.stream()
                            .map(Tekton::getIDNoPrint)
                            .collect(Collectors.toList())));

            // Insects on this Tekton
            List<Insect> insects = tekton.getInsectsNoPrint();
            System.out.println("Insects: " +
                    (insects == null || insects.isEmpty()
                            ? "None"
                            : insects.stream().map(Insect::getIDNoPrint).collect(Collectors.toList())));

            // Mushroom (if any)
            Mushroom mushroom = tekton.getMushroomNoPrint();
            if (mushroom != null) {
                System.out.println("Mushroom: " + mushroom);

                // MushroomBody
                MushroomBody body = mushroom.getMushroomBodyNoPrint();
                if (body != null) {
                    System.out.println("  Mushroombodies: " + body);
                    System.out.println("    MushroomBody ID: " + body.getIDNoPrint());
                    System.out.println("    MushroomBody Tekton: " + body.getTektonNoPrint().getIDNoPrint());
                } else {
                    System.out.println("  Mushroombodies: None");
                }

                // MushroomYarns
                List<MushroomYarn> yarns = mushroom.getMushroomYarnsNoPrint();
                if (yarns != null && !yarns.isEmpty()) {
                    System.out.println("  MushroomYarns: " +
                            yarns.stream().map(MushroomYarn::getIDNoPrint).collect(Collectors.toList()));
                    for (MushroomYarn yarn : yarns) {
                        System.out.println("    MushroomYarn ID: " + yarn.getIDNoPrint());
                        Tekton[] linked = yarn.getTektonsNoPrint();
                        System.out.println("    MushroomYarn Tektons: " +
                                linked[0].getIDNoPrint() + " and " + linked[1].getIDNoPrint());
                    }
                } else {
                    System.out.println("  MushroomYarns: None");
                }
            } else {
                System.out.println("Mushroom: None");
            }

            // Print each insect's details
            if (insects != null) {
                for (Insect insect : insects) {
                    final int insectId = insect.getIDNoPrint();
                    System.out.println();
                    System.out.println("Insect ID: " + insectId);
                    System.out.println("Insect Tekton: " + insect.getTektonNoPrint().getIDNoPrint());
                    System.out.println("Insect Player: " + insect.getOwnerNoPrint().getName());

                    int[] effects = insect.getEffectsNoPrint();
                    System.out.println("Insect is paralyzed for: " + effects[1]);
                    System.out.println("Insect can't cut for: " + effects[0]);
                    System.out.println("Insect is speeded for: " + effects[3]);
                    System.out.println("Insect is slowed for: " + effects[2]);
                }
            }
        }
    }

    /**
     * Retrieves the list of all Tektons currently in the game.
     *
     * @return A {@code List} containing all {@code Tekton} objects in the game.
     */
    public List<Tekton> getTektons() {
        return tektons;
    }

    /**
     * Retrieves the list of all players currently in the game.
     *
     * @return A {@code List} containing all {@code Player} objects participating in the game.
     */
    public List<Player> getPlayers(){
        return players;
    }

    /**
     * Advances the game to the next player's turn.
     * <p>
     * This method determines the next player in the turn order. If the current
     * player is the last in the list, the turn cycles back to the first player,
     * and a game update is triggered. Otherwise, the active player is set to the
     * next player in the list.
     * </p>
     */
    public Player getActivePlayer() {
        return activePlayer;
    }
    public void nextPlayer(){
        int index = players.indexOf(activePlayer);

        if(index == players.size()-1){
            activePlayer = players.get(0);
            this.update();
        } else{ activePlayer = players.get(index + 1); }
    }

    /**
     * Determines the winner of the game based on player scores.
     * <p>
     * This method iterates through all the players in the game and identifies
     * the player with the highest score as the winner. The winner's information
     * is then printed to the console.
     * </p>
     */
    public Player determineMushroomerWinner() {
        Player winnerMushroomer = players.get(0);
        for (Player player : players) {
            if (player.getPlayerType() == Player.PlayerType.MUSHROOMER) {
                if (winnerMushroomer.getScore() < player.getScore()) {
                    winnerMushroomer = player;
                }
            }
        }
        System.out.println("the mushroomer winner is: " + winnerMushroomer.getName() + " with score: " + winnerMushroomer.getScore());
    return  winnerMushroomer;
    }
    public Player determineInsecterWinner(){
        Player winnerInsecter = players.get(0);
        for (Player player : players) {
            if (player.getPlayerType() == Player.PlayerType.INSECTER) {
                if (winnerInsecter.getScore() < player.getScore()) {
                    winnerInsecter = player;
                }
            }
        }
        System.out.println("the insecter winner is: "+ winnerInsecter.getName() + " with score: "+ winnerInsecter.getScore());
        return winnerInsecter;
    }

    /**
     * Updates the state of all insects and mushrooms in the game for the current turn.
     * <p>
     * This method iterates through all the Tektons in the game and then updates
     * each insect residing on that Tekton by calling its {@code nextTurn()} method.
     * Additionally, it updates the mushroom associated with each Tekton by calling
     * its {@code Update()} method.
     * </p>
     */
    public void update(){
        System.out.println("Game.update() called");
        //update all insects and mushrooms
        List<MushroomYarn> mushroomYarns = new ArrayList<>();
        for (Tekton tekton : tektons) {
            for(Insect insect : tekton.getInsects()){
                insect.nextTurn();
            }
            mushroomYarns.addAll(tekton.getMushroom().Update());
            System.out.println("UPDATEEEEEEEEEEEEEEEEEEEEEE");
        }
        if(!mushroomYarns.isEmpty()){
            for (MushroomYarn mushroomYarn : mushroomYarns) {
                mushroomYarn.getOwner().getMushroomYarns().remove(mushroomYarn);
                mushroomYarn.getTektons()[0].getMushroom().getMushroomYarns().remove(mushroomYarn);
                mushroomYarn.getTektons()[1].getMushroom().getMushroomYarns().remove(mushroomYarn);
            }
        }

        System.out.println("Game.update() returned");
    }



}
